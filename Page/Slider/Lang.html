<html>

<head>
    <meta charset="UTF-8">
    <title>Язык программирования C#</title>
    <!-- Подключаем шрифт Montserrat с Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,600,700&display=swap" rel="stylesheet">
    <!-- Подключаем файл со стилями CSS -->
    <link rel="stylesheet" href="/Design/ProgaMasha.css">
    <link rel="stylesheet" href="/Design/Button.css">
    <script src="/Script/Button.js"></script>
</head>

<body>
    <div class="container">
        <div class="nav">
            <button onclick="location.href='/Main.html'" style="background-color: #ffffff00; border: 0;"> <!-- Вернуться на гл. страницу через клик по картинке-->
                <img src="/Image/JoyStick2.png" alt="Логотип" class="logo">    
            </button>
            <div class="dropdown">
                <div class="dropdown">
                    <button onclick="myFunction2()" class="dropbtn">Тесты</button>
                    <div id="myDropdown2" class="dropdown-content">
                    <ul>
                        <li><a href="/Page/GitHub.html">GitHub</a></li>
                        <li><a href="/Page/Lang.html">C#</a></li>
                        <li><a href="/Page/Unity.html">Unity</a></li>
                    </ul>
                    </div>
                </div> 
                <div class="dropdown">    
                    <button onclick="myFunction()" class="dropbtn">Темы</button>
                    <div id="myDropdown" class="dropdown-content">
                    <ul>
                        <li><a href="#id1">Тема 1</a></li>
                        <li><a href="#id2">Тема 2</a></li>
                        <li><a href="#id3">Тема 3</a></li>
                    </ul>
                    </div>
                </div>
            </div>  
        </div>
    </div>
    <div class="container">
        <div class="content">
            <div class="card">
                <h1>Язык программирования C#</h1>

                <div style="display: flex; justify-content: center; margin-top: 20px; margin-bottom: 50px;">
                    <img src="\Image\Lang.jpg"  width="900vh" style="border-radius: 10px; max-width: 100%;">
                  </div>                  
                
                <p><strong>C# </strong>- это современный, мощный и универсальный язык, который можно использовать для разработки различных приложений, в том числе игр. В этом тексте я расскажу тебе о некоторых основных концепциях и элементах языка C#, таких как:</p>                

                <p><strong>Переменные</strong> - это именованные области памяти, в которых хранятся данные разных типов, например, числа, строки, булевы значения и т.д. Переменные объявляются с указанием их типа и имени, например: int x = 10; - это переменная типа int (целое число) с именем x и значением 10.</p>
                <p><strong>Методы</strong> - это блоки кода, которые выполняют определенную задачу и могут принимать и возвращать значения. Методы объявляются с указанием их возвращаемого типа, имени и параметров, например: double Square(double x) - это функция типа double (вещественное число) с именем Square и параметром x, которая возвращает квадрат своего аргумента.</p>
                <p><strong>ООП</strong> - это объектно-ориентированное программирование, это подход к разработке программ, в котором данные и поведение организуются в виде классов и объектов. Класс - это шаблон, который определяет свойства и методы своих объектов. Объект - это экземпляр класса, который имеет конкретные значения свойств и может вызывать методы. Например: class Person - это класс, который описывает человека, Person p = new Person("Alice", 25); - это объект класса Person с именем p, который имеет свойства name и age со значениями "Alice" и 25.</p>
                <p><strong>Скрипты</strong> движения персонажа, прыжок, атаки, враги и многое другое - это различные аспекты разработки игр на C#, которые требуют знания физики, математики, графики и логики. Для создания игр на C# можно использовать специальные среды и фреймворки, такие как Unity, MonoGame, XNA и т.д. В этих средах можно писать скрипты, которые управляют поведением объектов на сцене, например: void Update() - это функция, которая вызывается каждый кадр и в которой можно обрабатывать ввод пользователя, перемещать и взаимодействовать с объектами, проверять столкновения и т.д.</p>
                <button onclick="location.href='/Main.html'" type="button" class="back-button">
                    Назад
                </button>
            </div>
            <br>
            
            <div class="card">
                <h1>1. Переменные</h1>
                <p>Как и во многих языках программирования, в C# есть своя система типов данных, которая используется для создания переменных. Тип данных определяет внутреннее представление данных, множество значений, которые может принимать объект, а также допустимые действия, которые можно применять над объектом.</p>
                <p>В языке C# есть следующие базовые типы данных:</p>
                <ul>
                    <li><strong>bool</strong>: хранит значение true или false (логические литералы). Представлен системным типом System.Boolean</li>
                    <li><strong>byte</strong>: хранит целое число от 0 до 255 и занимает 1 байт. Представлен системным типом System.Byte</li>
                    <li><strong>sbyte</strong>: хранит целое число от -128 до 127 и занимает 1 байт. Представлен системным типом System.SByte</li>
                    <li><strong>short</strong>: хранит целое число от -32768 до 32767 и занимает 2 байта. Представлен системным типом System.Int16</li>
                    <li><strong>ushort</strong>: хранит целое число от 0 до 65535 и занимает 2 байта. Представлен системным типом System.UInt16</li>
                    <li><strong>int</strong>: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта. Представлен системным типом System.Int32. Все целочисленные литералы по умолчанию представляют значения типа int:</li>
                    <li><strong>uint</strong>: хранит целое число от 0 до 4294967295 и занимает 4 байта. Представлен системным типом System.UInt32</li>
                    <li><strong>long</strong>: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт. Представлен системным типом System.Int64</li>
                    <li><strong>ulong</strong>: хранит целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт. Представлен системным типом System.UInt64</li>
                    <li><strong>float</strong>: хранит число с плавающей точкой от $$-3.4*10^{38}$$ до $$3.4*10^{38}$$ и занимает 4 байта. Представлен системным типом System.Single</li>
                    <li><strong>double</strong>: хранит число с плавающей точкой от $$\pm 5.0*10^{-324}$$ до $$\pm 1.7*10^{308}$$ и занимает 8 байта. Представлен системным типом System.Double</li>
                    <li><strong>decimal</strong>: хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от $$\pm 1.0*10^{-28}$$ до $$\pm 7.9228*10^{28}$$, может хранить 28 знаков после запятой и занимает 16 байт. Представлен системным типом System.Decimal</li>
                    <li><strong>char</strong>: хранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом System.Char. Этому типу соответствуют символьные литералы:</li>
                    <li><strong>string</strong>: хранит набор символов Unicode. Представлен системным типом System.String. Этому типу соответствуют строковые литералы.</li>
                    <li><strong>object</strong>: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом System.Object, который является базовым для всех других типов и классов .NET.</li>
                </ul>
                <p>Например, определим несколько переменных разных типов и выведем их значения на консоль:</p>
                    <pre><code class="language-csharp">string name = "Tom";
                        int age = 33;
                        bool isEmployed = false;
                        double weight = 78.65;
                        
                        Console.WriteLine($"Имя: {name}");
                        Console.WriteLine($"Возраст: {age}");
                        Console.WriteLine($"Вес: {weight}");
                        Console.WriteLine($"Работает: {isEmployed}");
                    </code></pre>

                <p>Для вывода данных на консоль здесь применяется интерполяция: перед строкой ставится знак $ и после этого мы можем вводить в строку в фигурных скобках значения переменных. Консольный вывод программы:</p>
                    <pre><code>
                        Имя: Tom
                        Возраст: 33
                        Вес: 78,65
                        Работает: False
                    </code></pre>
            </div>            
            <br>

            <div class="card">
                <h1>2. Методы</h1>
                <p>Если переменные хранят некоторые значения, то методы содержат собой набор инструкций, которые выполняют определенные действия. По сути метод - это именованный блок кода, который выполняет некоторые действия.</p>
                <p>Общее определение методов выглядит следующим образом:</p>
                <pre><code class="language-csharp">[модификаторы] тип_возвращаемого_значения название_метода ([параметры])
            {
                // тело метода
            }</code></pre>
                <p>Модификаторы и параметры необязательны.</p>
                <p>Ранее мы уже использовали как минимум один метод - Console.WriteLine(), который выводит информацию на консоль. Теперь рассмотрим, как мы можем создавать свои методы.</p>
                <h2>Определение метода</h2>
                <p>Определим один метод:</p>
                <pre><code class="language-csharp">void SayHello()
            {
                Console.WriteLine("Hello");
            }</code></pre>
                <p>Здесь определен метод SayHello, который выводит некоторое сообщение. К названиям методов предъявляются в принципе те же требования, что и к названиям переменных. Однако, как правило, названия методов начинаются с большой буквы.</p>
                <p>Перед названием метода идет возвращаемый тип данных. Здесь это тип void, который указыает, что фактически ничего не возвращает, он просто производит некоторые действия.</p>
                <p>После названия метода в скобках идет перечисление параметров. Но в данном случае скобки пустые, что означает, что метод не принимает никаких параметров.</p>
                <p>После списка параметров в круглых скобках идет блок кода, который представляет набор выполняемых методом инструкций. В данном случае блок метода SayHello содержит только одну инструкцию, которая выводит строку на консоль:</p>
                <pre><code class="language-csharp">Console.WriteLine("Hello");</code></pre>
                <p>Но если мы запустим данный проект, то мы не увидим никакой строки, которую должен выводить метод SayHello. Потому что после определения метод еще надо вызвать, чтобы он выполнил свою работу.</p>
                <h2>Вызов методов</h2>
                <p>Чтобы использовать метод SayHello, нам надо его вызвать. Для вызова метода указывается его имя, после которого в скобках идут значения для его параметров (если метод принимает параметры).</p>
                <pre><code class="language-csharp">название_метода (значения_для_параметров_метода);</code></pre>
                <p>Например, вызов метода SayHello будет выглядеть следующим образом:</p>
                <pre><code class="language-csharp">SayHello();</code></pre>
                <p>Поскольку метод не принимает никаких параметров, то после названия метода идут пустые скобки.</p>
                <p>Объединим определение и вызов метода:</p>

                <div id="black-rectangle"></div>
                <pre><code class="language-csharp">void SayHello()
                {
                  Console.WriteLine("Hello");
                }
                 
                SayHello(); // Hello
                SayHello(); // Hello</code></pre>
                
            </div>
            <br>
            
            <div class="card">
                <h1>3. Принципы ООП</h1>
                <h2>Инкапсуляция</h2>
                <p>Инкапсуляция в программировании является объединением данных и кода, работающего с этими данными, в большинстве случае это сводится к тому, чтобы не давать доступа к важным данным напрямую. Вместо этого мы создаем ограниченный набор методов, с помощью которых можно работать с нашими данными. Давайте рассмотрим несколько повседневных примеров, чтобы лучше понять это.</p>
                <h3>Пример: Уровень заряда батареи смартфона</h3>
                <pre><code class="language-csharp">public class Smartphone
            {
                private int _batteryLife;
            
                // Метод заряжает батарею, но не имеет доступа к уровню заряда
                public void Charge(int amount)
                {
                    // Устанавливаем свои правила для работы с переменной
                    if (amount <= 0)
                    {
                        throw new ArgumentException("В метод для зарядки телефона передано значение меньше либо равное нулю")
                    }
                  
                    _batteryLife += amount;
                }
            
                // Метод получает текущее значение, но не может его изменить
                public int GetBatteryLife()
                {
                    return _batteryLife;
                }
            }</code></pre>
                <p>Здесь _batteryLife — это наши важные данные. У нас есть методы для зарядки и показа текущего значения, однако мы не даем доступ к самой переменной _batteryLife, поэтому, например, пользователи класса не смогут убавить значение нашей переменной.</p>
                <h3>Пример: Избранные песни</h3>
                <p>Давайте представим музыкальное приложение, в котором можно добавлять или удалять песни из своего списка избранного.</p>
                <pre><code class="language-csharp">public class MusicApp
            {
                private List<string> _favoriteSongs = new List<string>();
            
                public void AddToFavorites(string songName)
                {
                    if(!string.IsNullOrEmpty(songName) && !_favoriteSongs.Contains(songName))
                    {
                        _favoriteSongs.Add(songName);
                    }
                }
            
                public void RemoveFromFavorites(string songName)
                {
                    _favoriteSongs.Remove(songName);
                }
            
                public List<string> GetFavorites()
                {
                    return new List<string>(_favoriteSongs);
                }
            }</code></pre>
                <p>В этом примере инкапсулирован, то есть спрятан от доступа извне класса, список наших избранных песен (_favoriteSongs). Мы предоставляем методы для управления списком, но не даем возможности работать со списком напрямую.</p>
            </div>
            
            <br>
            
            <div class="card">
                <h1>4. Скрипты</h1>
                <p>Приветствую! В данной статье мы разберём правильную реализацию движения персонажа. Поскольку движение 2D и 3D персонажей почти на 100% эдентичны, то мы поочереди их и разберём. Благодаря чему, начинающий разработчик не только разберётся в том, как реализовать функцию передвижения, но увидит разницу между движениями 2D и 3D.</p>
                <h2>Передвижение 2D персонажа</h2>
                <p>Первым делом создадим игровой объект нашего персонажа, и назовём его, например, Player.</p>
                <img src="/Image/Передвижение.jpg" alt="Игровой объект Player" width="400" height="200">
                <p>Далее добавим к нашему персонажу компонент Rigidbody 2D. Если в Вашей игре отсутствуют законы гравитации, то в в поле Body Type необходимо указать значение "Kinematic".</p>
                <p>P.S. Обычно гравитация отсутствует в 2д играх с видом сверху.</p>
                <img src="/Image/Гравитация.jpg" alt="Компонент Rigidbody 2D" width="400" height="250">
                <p>Теперь самое интересное, нам необходимо создать C# скрипт с названием, например movePlayer, и присвоить этот скрипт нашему объекту Player. А сам скрипт должен иметь следующее содержимое:</p>
                <pre><code class="language-csharp">using System.Collections;
            using System.Collections.Generic;
            using UnityEngine;
            
            public class movePlayer : MonoBehaviour
            {
                private Rigidbody2D rb;
                public float speed = 0.5f;
                private Vector2 moveVector;
            
                void Awake()
                {
                    rb = GetComponent<Rigidbody2D>();
                }
            
                void Update()
                {
                    moveVector.x = Input.GetAxis("Horizontal");
                    moveVector.y = Input.GetAxis("Vertical");
                    rb.MovePosition(rb.position + moveVector * speed * Time.deltaTime);
                }
            }</code></pre>
                <p>Готово! Давайте разберём наш код. В строках 7,8,9 мы создали 3 переменные:</p>
                <ul>
                    <li><strong>rb</strong> - которая будет хранить ссылку на компонент Rigidbody2D</li>
                    <li><strong>speed</strong> - скорость передвижения вашего персонажа</li>
                    <li><strong>moveVector</strong> - направление движения персонажа в виде вектора</li>
                </ul>
                <p>Далее в 13 строке мы в переменную rb присваивает ссылку на наш компонент Rigidbody2D, чтобы в дальнейшем можно было бы работать с его свойствами и методами.</p>
                <p>В строке 18 в переменную moveVector.x мы записываем значение движения по горизонтали. Если максимально простыми словами, то при нажатии на клавишу "D", в переменной записывается значение "1" - вперёд. При нажатии на клавишу "A" - в переменную записывается "-1" - назад.</p>
                <p>Аналогичная ситуация происходит и в 19 строке. При нажатии на клавишу "W", в переменной записывается значение "1" - вверх. При нажатии на клавишу "S" - в переменную записывается "-1" - вниз.</p>
                <p>Ну и в 20 строке, с помощью метода MovePosition, мы заставляем двигаться нашего персонажа, исходя из значений которые мы получили в moveVector.</p>

                <h2>Создание прыжка</h2>
                <p>Для создания прыжка, создадим скрипт С# для нашего персонажа, с названием, например, JumpPlayer. И пропишем в него следующий код:</p>
                <pre><code class="language-csharp">using UnityEngine;

                public class jumpPlayer : MonoBehaviour
                {
                    private Rigidbody2D rb;
                    public float jumpForce = 5.0f;

                    void Awake()
                    {
                        rb = GetComponent<Rigidbody2D>();
                    }

                    void Update()
                    {
                    if (Input.GetKeyDown(KeyCode.Space))
                        {
                            rb.AddForce(new Vector2(0, jumpForce), ForceMode2D.Impulse);
                        }
                    }
                }</code></pre>
                <p>Вкратце разберём наш код:</p>
                <ul>
                    <li>В строке #5 и #6 мы создаём две переменные. Переменная rb будет хранить ссылку на компонент Rigidbody2D, а переменная jumpForce указывает силу прыжка.</li>
                    <li>В десятой строке мы присваивает переменной rb ссылку на компонент Rigidbody2D.</li>
                    <li>В строке #15 мы проверяем, была ли нажата клавиша "Пробел" ? Если да, то в строке #17, с помощью метода Rigidbody2D.AddForce, выполняем прыжок персонажа.</li>
                </ul>
                <p>На этом всё. Но не совсем :)</p>
                <p>Дело в том, что при такой реализации прыжка, наш персонаж может прыгать даже в тех случаях, когда он не находится на земле. Тем самым персонаж становится летающим, будто птичка из игры Flappy Bird.</p>
                <p>Для исправления этого бага, нам необходимо каждый раз перед прыжком, проверять наличие земли под ногами персонажа.</p>
                <h2>Проверка на наличие земли под ногами персонажа.</h2>
                <pre><code class="language-csharp">using UnityEngine;
                    public bool isGround;
                        public float rayDistance = 0.6f;

                        RaycastHit2D hit = Physics2D.Raycast(rb.position, Vector2.down, rayDistance, LayerMask.GetMask("Ground"));

                        if (hit.collider != null)
                        {
                            isGround = true;
                        }
                        else
                        {
                            isGround = false;
                        }
                </code></pre>
                <p>В строке #1 и #2 мы создали две дополнительные переменные. Переменная isGround будет хранить информацию о том, есть ли под ногами земля или нет. True - есть, а False - нету.

                    В строке #4 с помощью метода Raycast мы выпускаем лучь под ноги нашего персонажа, который ищет там землю. Земля это объект, который имеет слой Ground. Поэтому обязательно создайте слой с именем Ground, и присвойте его всем объектам земли.
                    
                    Весь остальной код, начиная со строки #6, мы проверяем, нашёл ли наш луч землю под ногами, и если да, то в переменную isGround заносим значение true, если нет, то false.
                    
                    Так же обратите своё внимание на то, что длину луча, которая записана в переменную rayDistance, необходимо отрегулировать под высоту вашего персонажа. Поэтому, если Ваш персонаж высокий, то и значение луча необходимо увеличить.</p>
            </div>
        <br>
    </div>
</body>
</html>